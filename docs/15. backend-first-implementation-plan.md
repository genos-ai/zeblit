# Zeblit Backend-First Implementation Plan

*Version: 1.0.0*
*Author: Zeblit Development Team*
*Last Updated: 2025-01-11*

## Executive Summary

This document outlines a comprehensive implementation plan for completing the Zeblit AI Development Platform with a backend-first approach. The backend will serve as the single source of truth with all business logic, while clients (CLI, Telegram, Web) remain thin presentation layers.

## Architecture Principles

### 1. Backend-First Design
- **ALL business logic** lives in the backend
- Clients are purely presentation layers
- Single unified API serves all client types
- No client-specific endpoints or logic

### 2. API Design
- **REST API** for CRUD operations
- **WebSockets** for real-time updates
- **JSON** as the standard data format
- **JWT + API Keys** for authentication

### 3. Execution Model
- **ALL code execution** happens in backend containers
- Clients never execute user code locally
- Output streaming via WebSockets
- File operations through upload/download API

## Phase 1: Core Backend Completion (Weeks 1-2)

### 1.1 Container Management ✅ High Priority - COMPLETED
**Goal**: Complete OrbStack/Docker integration for isolated execution environments

#### Tasks:
- [x] Implement OrbStackClient class
  ```python
  # modules/backend/integrations/orbstack.py
  class OrbStackClient:
      async def create_container(project_id: UUID, template: str)
      async def start_container(container_id: str)
      async def stop_container(container_id: str)
      async def execute_command(container_id: str, command: str)
      async def get_container_logs(container_id: str)
      async def upload_file(container_id: str, file_path: str, content: bytes)
      async def download_file(container_id: str, file_path: str) -> bytes
  ```

- [x] Container lifecycle management
  - Auto-start on project access
  - Auto-stop after 30 minutes idle
  - Resource limit enforcement
  - Health monitoring

- [x] File synchronization
  - Upload project files to container
  - Sync changes back to database
  - Handle binary files

#### API Endpoints:
```yaml
# Container Management
POST   /api/v1/projects/{id}/container/start
POST   /api/v1/projects/{id}/container/stop
GET    /api/v1/projects/{id}/container/status
POST   /api/v1/projects/{id}/container/execute
GET    /api/v1/projects/{id}/container/logs
```

### 1.2 Console & Error Capture ✅ CRITICAL - COMPLETED
**Goal**: Implement real-time console capture for AI debugging

#### Tasks:
- [x] Console capture service
  ```python
  # modules/backend/services/console.py
  class ConsoleService:
      async def capture_output(project_id: UUID, output: ConsoleOutput)
      async def get_console_history(project_id: UUID) -> List[ConsoleOutput]
      async def analyze_errors(project_id: UUID) -> ErrorAnalysis
  ```

- [x] WebSocket endpoint for console streaming
  ```python
  @router.websocket("/ws/projects/{project_id}/console")
  async def console_websocket(websocket: WebSocket, project_id: UUID)
  ```

- [x] Redis storage for console logs
- [x] Error pattern detection
- [x] AI agent integration for auto-debugging

#### API Endpoints:
```yaml
# Console Management
WS     /api/v1/ws/projects/{id}/console
GET    /api/v1/projects/{id}/console/history
POST   /api/v1/projects/{id}/console/analyze
DELETE /api/v1/projects/{id}/console/clear
```

### 1.3 Agent-LLM Integration ✅ High Priority - COMPLETED
**Goal**: Connect agents to actual LLM providers

#### Tasks:
- [x] Complete LLM provider connections
  - Anthropic (Claude) - Primary
  - OpenAI - Fallback
  - Cost tracking per call

- [x] Agent conversation flow
  ```python
  # modules/backend/services/agent_orchestrator.py
  class AgentOrchestrator:
      async def process_user_message(user_id: UUID, project_id: UUID, message: str)
      async def route_to_agent(agent_type: AgentType, context: Dict)
      async def get_agent_response(agent_id: UUID, prompt: str) -> AgentResponse
  ```

- [x] Context management
  - Project files in context
  - Console logs in context
  - Previous conversations
  - Task history

#### API Endpoints:
```yaml
# Agent Interaction
POST   /api/v1/projects/{id}/chat
GET    /api/v1/projects/{id}/chat/history
POST   /api/v1/projects/{id}/agents/{agent}/direct
GET    /api/v1/agents/status
```

### 1.4 File Management API ✅ COMPLETED
**Goal**: Complete file operations through API

#### Tasks:
- [x] File service enhancements
  ```python
  class FileService:
      async def create_file(project_id: UUID, path: str, content: bytes)
      async def update_file(project_id: UUID, path: str, content: bytes)
      async def delete_file(project_id: UUID, path: str)
      async def get_file(project_id: UUID, path: str) -> bytes
      async def list_files(project_id: UUID, directory: str) -> List[FileInfo]
      async def get_file_tree(project_id: UUID) -> Dict
  ```

- [x] File versioning
- [x] Binary file support
- [x] Temporary file staging for uploads

#### API Endpoints:
```yaml
# File Management
POST   /api/v1/projects/{id}/files
GET    /api/v1/projects/{id}/files/{path}
PUT    /api/v1/projects/{id}/files/{path}
DELETE /api/v1/projects/{id}/files/{path}
GET    /api/v1/projects/{id}/files/tree
POST   /api/v1/projects/{id}/files/upload
GET    /api/v1/projects/{id}/files/download/{path}
```

### 1.5 Task Scheduling
**Goal**: User-defined scheduled tasks

#### Tasks:
- [ ] Scheduled task model
  ```python
  class ScheduledTask(Base):
      project_id: UUID
      name: str
      schedule: str  # Cron expression
      command: str
      enabled: bool
      last_run: datetime
      next_run: datetime
  ```

- [ ] Dynamic Celery Beat registration
- [ ] Execution in project container
- [ ] Result storage and notifications

#### API Endpoints:
```yaml
# Scheduled Tasks
POST   /api/v1/projects/{id}/schedules
GET    /api/v1/projects/{id}/schedules
PUT    /api/v1/projects/{id}/schedules/{schedule_id}
DELETE /api/v1/projects/{id}/schedules/{schedule_id}
GET    /api/v1/projects/{id}/schedules/{schedule_id}/runs
```

## Phase 2: Unified API Layer ✅ COMPLETED (Week 3)

### 2.1 API Gateway Pattern ✅ COMPLETED
**Goal**: Single entry point for all operations

#### Components:
- [x] Unified response format
  ```json
  {
    "success": true,
    "data": {},
    "error": null,
    "metadata": {
      "timestamp": "2025-01-11T10:00:00Z",
      "request_id": "uuid",
      "version": "1.0"
    }
  }
  ```

- [x] Error standardization
- [x] Rate limiting per API key
- [x] Request/response logging

### 2.2 Authentication System ✅ COMPLETED
**Goal**: Unified auth for all client types

#### Implementation:
- [x] API Key generation
  ```python
  class APIKeyService:
      async def generate_key(user_id: UUID, name: str) -> APIKey
      async def validate_key(key: str) -> Optional[User]
      async def revoke_key(key_id: UUID)
  ```

- [x] Telegram linking
  ```python
  class TelegramAuthService:
      async def generate_link_token(user_id: UUID) -> str
      async def link_telegram_account(token: str, telegram_id: int)
  ```

- [x] Multi-token support (one per client)

#### API Endpoints:
```yaml
# Authentication
POST   /api/v1/auth/keys
GET    /api/v1/auth/keys
DELETE /api/v1/auth/keys/{key_id}
POST   /api/v1/auth/telegram/link
POST   /api/v1/auth/telegram/verify
```

### 2.3 WebSocket Infrastructure ✅ COMPLETED
**Goal**: WebSocket infrastructure for all clients

#### Implementation:
- [x] Unified WebSocket manager
  ```python
  class WSConnectionManager:
      async def connect(client_id: str, client_type: ClientType)
      async def broadcast_to_project(project_id: UUID, event: Dict)
      async def send_to_client(client_id: str, event: Dict)
  ```

- [ ] Event types
  - Agent status updates
  - Console output
  - File changes
  - Task progress
  - Build/deployment status

#### WebSocket Events:
```yaml
# Event Types
agent.status: {agent_id, status, message}
console.output: {type, content, timestamp}
file.changed: {path, action, content}
task.progress: {task_id, progress, status}
build.status: {status, logs, artifacts}
```

## Phase 3: CLI Client ✅ COMPLETED (Week 4)

### 3.1 CLI Architecture ✅ COMPLETED
**Goal**: Lightweight CLI that talks to backend API

#### Structure:
```
zeblit-cli/
├── src/
│   ├── api/          # API client
│   ├── auth/         # Authentication
│   ├── commands/     # CLI commands
│   ├── config/       # Local config
│   └── utils/        # Helpers
├── setup.py
└── requirements.txt
```

### 3.2 Core Commands
```bash
# Authentication
zeblit auth login
zeblit auth logout
zeblit auth status

# Projects
zeblit create <name> --template=<template>
zeblit list
zeblit use <project_id>
zeblit delete <project_id>

# Development
zeblit chat "Build a todo app"
zeblit run <command>
zeblit logs
zeblit files list
zeblit files edit <path>
zeblit files upload <local_path> <remote_path>
zeblit files download <remote_path> <local_path>

# Scheduling
zeblit schedule create --name="backup" --cron="0 0 * * *" --command="python backup.py"
zeblit schedule list
zeblit schedule delete <schedule_id>

# Monitoring
zeblit status
zeblit console
zeblit errors
```

### 3.3 Implementation Details
- [ ] Python Click framework
- [ ] Async HTTP client (httpx)
- [ ] WebSocket client for real-time updates
- [ ] Local config in ~/.zeblit/config.json
- [ ] Pretty output with Rich library
- [ ] Progress bars for long operations
- [ ] Tab completion support

## Phase 4: Telegram Bot (Week 5)

### 4.1 Bot Architecture
**Goal**: Telegram bot as thin client

#### Structure:
```
zeblit-telegram/
├── src/
│   ├── api/          # Backend API client
│   ├── handlers/     # Message handlers
│   ├── keyboards/    # Reply keyboards
│   ├── middleware/   # Auth middleware
│   └── utils/        # Helpers
├── bot.py
└── requirements.txt
```

### 4.2 Bot Commands
```
/start - Welcome message
/link <api_key> - Link Zeblit account
/projects - List projects
/create <name> - Create new project
/use <project_id> - Select active project
/chat <message> - Talk to Dev Manager
/run <command> - Execute command
/logs - Show recent logs
/files - List files
/schedule - Manage schedules
/help - Show all commands
```

### 4.3 Implementation Details
- [ ] python-telegram-bot library
- [ ] Polling mode (not webhooks)
- [ ] Conversation handlers for multi-step flows
- [ ] Inline keyboards for project selection
- [ ] Code syntax highlighting in messages
- [ ] File upload/download support
- [ ] Notification preferences

## Phase 5: Testing & Documentation (Week 6)

### 5.1 API Testing
- [ ] Comprehensive API test suite
- [ ] Load testing with Locust
- [ ] WebSocket testing
- [ ] Error scenario testing

### 5.2 Integration Testing
- [ ] End-to-end workflows
- [ ] Multi-client scenarios
- [ ] Container lifecycle tests
- [ ] Agent interaction tests

### 5.3 Documentation
- [ ] API documentation (OpenAPI/Swagger)
- [ ] Client SDKs documentation
- [ ] Architecture diagrams
- [ ] Deployment guide
- [ ] User guides per client

## Implementation Checklist

### Week 1-2: Core Backend
- [ ] OrbStack container integration
- [ ] Console capture system
- [ ] Agent-LLM connection
- [ ] File management API
- [ ] Task scheduling

### Week 3: API Layer
- [ ] Unified API gateway
- [ ] Authentication system
- [ ] WebSocket infrastructure
- [ ] API documentation

### Week 4: CLI Client
- [ ] Basic CLI structure
- [ ] Authentication flow
- [ ] Project management
- [ ] Chat interface
- [ ] File operations

### Week 5: Telegram Bot
- [ ] Bot setup
- [ ] Account linking
- [ ] Command handlers
- [ ] Conversation flows
- [ ] Notifications

### Week 6: Polish
- [ ] Comprehensive testing
- [ ] Performance optimization
- [ ] Documentation
- [ ] Deployment scripts
- [ ] Monitoring setup

## Success Metrics

1. **Backend Performance**
   - API response time < 200ms
   - WebSocket latency < 50ms
   - Container startup < 5s
   - 99.9% uptime

2. **Client Experience**
   - CLI command execution < 1s
   - Telegram response < 2s
   - Real-time updates within 100ms
   - Zero client-side errors

3. **Developer Productivity**
   - Project creation to first run < 30s
   - AI response time < 5s
   - File sync < 1s
   - Error detection < 2s

## Migration Strategy

### From Current State:
1. Complete backend APIs without breaking existing web UI
2. Add versioning to all endpoints
3. Gradually migrate web UI to use new APIs
4. Deprecate old endpoints after all clients migrated

### Database Migrations:
- Add API keys table
- Add scheduled tasks table
- Add telegram_links table
- Update container model for new features

## Security Considerations

1. **API Security**
   - Rate limiting per API key
   - Request signing for sensitive operations
   - Audit logging for all actions
   - Encrypted storage for secrets

2. **Container Security**
   - Network isolation
   - Resource limits
   - No privileged operations
   - Read-only root filesystem

3. **Data Security**
   - Encryption at rest
   - Encryption in transit (TLS)
   - User data isolation
   - Regular security audits

## Conclusion

This backend-first approach ensures:
- Single source of truth for all business logic
- Easy addition of new client types
- Consistent behavior across all clients
- Simplified maintenance and updates
- Better security and control

The implementation focuses on completing the backend API layer first, making it fully functional before adding any new clients. This ensures that whether users prefer CLI, Telegram, or Web interfaces, they get the same powerful Zeblit experience.
